-Capítulo 1 -- Introdução

1.	A linguagem C é uma das mais bem-secedidas linguagens de alto nível já criadas e considerada uma das linguagens de programação mais utilizadas de todos os tempos.
	Define-se como linguagem de alto nível aquela que possui um nível de abstração relativamente elevado, que está mais próximo da linguagem humana do que do código de máquina. Ela foi criada em 1972, nos laboratórios Bell, por Deniis Ritchie, sendo revisada e padronizada pelo ANSI (American National Standards Institute) em 1989.
	A linguagem C é uma linguagem procedural, ou seja, ela permite que um problema complexo seja facilmente decomposto em módulos, sendo cada módulo um problema mais simples. Além disso, ela fornece acesso de baixo nível à memória, o que permite o acesso e a programação direta do microprocessador. Ela também permite a implantação de programas utilizando instruções em Assembly, o que possibilita programar problemas em que a depencência do tempo é critica.
	Por fim, a linguagem C foi criada para incentivar a programação multiplataforma, ou seja, programas escritos em C podem ser compilados para uma grande variedade de plataformas e sistemas operacionais com apenas pequenas alterações no seu código-fonte.
	
2.	A linguagem C tem influenciado, direta ou indiretamente, muitas linguagens desenvolvidas posteriormente, como C++, Java, C# e PHP.
	Provavelmente a influência mais marcante da linguagem foi a sua sintática: todas as mencionadas combinam a sintaxe de declaração e a sintaxe da expressão da linguagem C com sistemas de tipo, modelos de dados etc.

3.	Um debugger nada mais é do que um programa de computador usado para testar e depurar (limplar, purificar) outros programas. Entre as principais funcionalidades de um debugger estão:
	º A possibilidade de executar um programa passo a passo.
	º Pausar o programa em pontos predefinidos, chamados pontos de parada ou breakpoints, para examinar o estado atual de suas variáveis.

4.	Um Biblioteca é um conjunto de funções (pedaçõs de código) já implementados e que podem ser utilizados pelo programador.

5.	Todo programa em linguagem C deve conter a função main(). Essa função é responsável pelo início da execução do programa, e é dentro dela que colocamos os comandos que queremos que o programa execute.

6.	As chaves definem o início ("{") e o fim ("}") de um bloco de comandos/instruções.

7.	Os parênteses definem o início ("(") e o fim (")") da lista de argumentos de uma função. Um argumento é a informação que será passada para a função agir.

8.	Outra coisa importante que devemos ter em mente quando escrevemos um programa é a indentação do código. Trata-se de um convenção de escrita de códigos-fonte que visa a modificar a estética do programa para auxiliar a sua leitura e interpretação. A indentação torna a leitura do código-fonte muito mais fácil e facilita a sua modificação.
	A indentação é o espaçamento (ou tabulação) colocado antes de começar a escrever o código na linha. Ela tem como objetivo indicar a hierarquia dos elementos. O ideal é sempre criar um novo nível de indentação para um novo bloco de comandos.

9.	O código-fonte de um programa nada mais é do que um conjuntoo de palavras e/ ou símbolos. Nele estão as instruções do que o programa deve fazer. O código-fonte é normalmente escrito de uma forma que facilite a leitura pelos seres humanos, no caso o programador. Ele não tem nenhum significado para o computador, que somente entende códigos de máquina. Para fazer com que o nosso código-fone seja entendido como um programa pelo computador, é preciso traduzi-lo para esse código de máquina. A essa tradução damos o nome compilação.

10.	A compilação é vulgarmente entendida como apenas uma etapa de tradução, mas na verdade ela é um conjunto de etapas:
	º Pré-processamento: antes de iniciar a compilação do nosso código-fonte, o arquivo é processado por um pré-processador. O arquivo de código-fone é convertido em outro arquivo de código-fonte "expandido". Nessa etapa, ocorrem a remoção dos comentários e a interpretação das diretivas de compilação utilizadas, as quais se iniciam com #.

	º Verificação sintática: aqui se verifica se o código-fonte foi escrito corretamente, de acordo com a linguagem C. Basicamente, a verificação sintática procura por erros de sintaxe como, por exemplo, parênteses que não foram fechados, falta de ponto e vírgula no final de uma instrução etc.

	º Compilação: cada arquivo de código-fonte do seu programa é processado, sendo criado um arquivo "objeto" para cada um deles. Nessa etapa, não é gerado nenhum arquivo que o usuário possa executar. Em vez disso, o compilador produz as instruções de linguagem de máquina que correspondem ao arquivo de código-fonte compilado.

	º Link-edição: o trabalho do link-editor é unir todos os arquivos "objeto" que fazem parte do programa em um único arquivo executável, o programa propriamente dito. Isso inclui tanto os arquivos objeto gerados na etapa de compilação a partir dos arquivos de código-fonte do programa como os arquivos objeto que foram gerados a partir das bibliotecas usadas.

11.	Um comentário, como o próprio nome diz, é um trecho de texto incluído dentro do programa para descrever alguma coisa, por exemplo, o que aquele pedaço do programa faz. Os comentários não modificam o funcionamento do programa porque são ignorados pelo compilador e servem, portanto, apenas para ajudar o programador a organizar o seu código.
	Para tanto, a linguagem C permite fazer comentários de duas maneiras diferentes: por linha ou por bloco:
	º Se o programador quiser comentar uma única linha de código, basta adicionar // na frente da linha. Tudo o que vier na linha depois do // será consirado comentário e ignorado pelo compilador.
	º Se o programdor quiser comentar mais de uma linha do código, isto é, um bloco de linhas, basta adicionar /* no começo da primeira linha de comentário e */ no final da última linha de comentário. Tudo o que vier depois do símbolo de /* e antes do */ será considerado comentário e ignorado pelo compilador.
	Outro aspecto importante do uso dos comentários é que eles permitem fazer a documentação interna de um programa, ou seja, permitem descrever o que cada bloco de comandos daquele programa faz.
	Os comentários dentro de um código permitem que um programador entenda muito mais rapidamente um código que nunca tenha visto ou relembre o que faz um techo de código há muito tempo implementado por ele. Além disso, saber o que determinado trecho de código realmente faz aumenta as possibilidades de reutilizá-lo em outras aplicacões.

12.	O comando #include é utilizado para declarar as bibliotecas que serão utilizadas pelo programa. Esse comando diz ao pré-processador para tratar o conteúdo de um arquivo especificado como se o seu conteúdo tivesse sido digitado no programa no ponto em que o comando #include aparece.
	O comando include permite duas sintaxes:
	º #include <nome-da-biblioteca>: o pré-processador procurará pela biblioteca nos caminhos de procura pré-especificados do compilador. Usamos essa sintaxe quando estamos incluindo uma biblioteca que é própria do sistema, com as bibliotecas stdio.h e stdlib.h.
	
	º #include "nome-da-biblioteca": o pré-processador procurará pela biblioteca no mesmo diretório onde se encontra o nosso programa. Podemos ainda optar por informar o nome do arquivo com o caminho completa, ou seja, em qual diretório ele se encontra e como chegar até lá.

13.	A linguagem C nos permite criar nossa própria biblioteca. Nela, podemos coloar função, estruturas etc., o que torna mais prática e fácil a sua utilização em outros projetos. Uma biblioteca é como o seu arquivo de código-fonte principal, com a diferença de que ele não possui a função main(). Isso ocorre porque o seu programa não vai começar na biblioteca.

14. Para se criar uma biblioteca, precisamos criar dois arquivos:
	º Cabeçalho (ou header) da biblioteca: esse arquivo contém as declarações e definições do que está contido dentro da biblioteca. Aqui são definidas quais função (apenas o seu protótipo), tipos e variáveis farão parte da biblioteca. Sua extensão é .h.

	º Código-fonte da biblioteca: arquivo que contém a implementação das funções definidas no cabeçalho e também qualquer biblioteca adicional de que nossas funções precisem para funcionar. Sua extensão é .c.

	Independetemente de precisarmos ou não incluir outras bibliotecas, devemos sempre incluir nossa própria biblioteca (header) no código-fonte. Para isso, usamos #include "<nome-do-header.h>.
	Por fim, temos de incluir nossa biblioteca no nosso programa.
	
-------------------------------
-Capítulo 2 -- Lendo e escrevendo nas variáveis

1. Toda informação contida dentro de um programa está armazenada na memória do computador. Nossos dados, em particular, estão sempre guardados dentro de uma variável. Em computação, uma variável é uma posição de memória onde poderemos guardar determinado dado ou valor e modificá-lo ao longo da execução do programa.
	Quando criamos uma variável e armazenamos um valor dentro dela, o computador reserva um espaço associado a um endereço de memória onde podemos guardar o valor dessa variável.

2.	Em linguagem C, a declaração de uma variável pelo programador segue a esta forma geral: tipo_da_variável nome_da_variável.
	O tipo_da_variavel dtermina o conjunto de valores e de operações que uma variável aceita, ou seja, que ela pode executar. Já o nome_da_variável é como o programador identifica essa variável dentro do programa. Ao nome da variável o computador associa o endereço do espaço que ele reservou na memória para guardá-la.
	Mais de uma variável pode ser declarada para um mesmo tipo ao mesmo tempo. Para tanto, basta separar cada nome de variável por uma vírgula: int x, y, z;

3. O operador de ponto e vírgula é utilizado para separar as instruções na linguagem C que compõem um programa de computador.

4.	Apenas quando declaramos uma variável é que o computador reserva um espaço de memória para guardarmos nossos dados. Assim, não é possível usar esse espaço antes de tê-lo reservado na memória.

5.	Quando falamos em memória do computador, não existe o conceito de posição de memória "vazia". Toda posição de memória do computador está preenchida com um conjunto de 0s e 1s. O que ocorre é que a posição de memória pode apenas não estar sendo utilizada. Portanto, ao criarmos uma variável, o computador seleciona uma posição que não estava sendo usada para guardar a nossa variável e, portanto, ela automaticamente estará preenchida com um valor chamado de "lixo de memória": um conjunto de 0s e 1s sem significado para o nosso programa.

6.	Quando criamos uma variável, o computador reserva um espaço de memória onde podemos guardar o valor associado a ela. Ao nome que damos a essa variável o computador associa o endereço do espaço que ele reservou na memória para guardá-la. De modo geral, interessa ao programador saber o nome das variáveis. Porém, existem algumas regras para a escolha dos nomes das variáveis na linguagem C:
	° O nome de uma variável é um conjunto de caracteres que podem ser letras, números ou underscores(_).
	° O nome de uma variável deve sempre iniciar com uma letra ou o underscore(_).

7.	A linguagem C é case-sensitive, ou seja, uma palavra escrita utilizando caracteres maiúsculos é diferente da mesma palavra escrita com caracteres minúsculos. Sendo assim, as palavras Soma, soma e SOMA são consideradas diferentes para a linguagem C e representam TRÊS variáveis distintas.

8.	As palavras-chave são um conjunto de 32 palavras reservadas dentro da linguagem C. São elas que formam a sintaxe da linguagem C. Essas palavras já possuem funções específicas dentro da linguagem de programação e, por esse motivo, não podem ser utilizadas para outro fim, como para nomes de variáveis.

9.	A linguagem C possui um total de cinco tipos de dados básicos:
	° O tipo char: esse tipo de dados permite armazenar em um único byte (8 bits) um número inteiro muito pequeno ou o código de um caractere do conjunto de caracteres da tabela ASCII.
	Lembre-se: uma única letra poder o nome de uma variável. As aspas simples permitem que o compilador saiba que estamos inicializando nossa variável com um caractere e não com o conteúdo de outra variável.

	° O tipo int: o segundo tipo de dado é o tipo inteiro. Esse tipo de dados permite armazenar um número inteiro (sem parte fracionária). Seu tamanho depende do processador em que o programa está rodando e é tipicamente 16 ou 32 bits.

	° Os tipos float e double: o terceiro e quarto tipos de dados são os tipos reais: float e double. Esses tipos de dados permitem armazenar um valor real ( com parte fracionária ), também conhecido como ponto flutuante. A diferença entre eles é a sua precisão: 
		° tipo float: precisão simples;
		° tipo double: dupla precisão.
	São úteis quando queremos trabalhar com intervalos de números reais realmente grandes.
	A notação científica é uma forma de escrever números extremamente grandes ou extremamente pequenos. Nesse caso, o valor real é seguido por uma letra "e" ou "E" e um número inteiro (positivo ou negativo), que indica o expoente da base 10(representado pela letra "e" ou "E" que multiplica o número).

	° O tipo void: esse tipo de dados permite declarar uma função que não retorna valor ou um ponteiro genérico, como será visto nas próximas seções.
	A linguagem C não permite que se declare uma variável do tipo void. Esse tipo de dados só deve ser usado para declarar funções que não retornam valor ou ponteiro genérico.


10.	Além dos cinco tipos básicos, a linguagem C, possui quatro modificadores de tipos. Eles são aplicados precedendo os tipos básicos (com exceção do tipo void), e permitem alterar o significado do tipo, de modo a adequá-lo às necessidades do nosso programa. São eles: signed, unsigned, short e long:
	
	° O modificador signed: esse modificador determina que uma variável declarada dos tipos char out int poderá ter valores positivos ou negativos. Trata-se do modo-padrão de definição de variáveis desses tipos, e, por esse motivo, raramente é usado.
	
	° O modificador unsigned: esse modificador determina que uma variável declarada dos tipos char out int somente poderá ter valores positivos e o valor zero. Nesse caso, a variável perde seu bit de sinal, o que dobra a sua capacidade de armazenamento para valores positivos. Por exemplo, uma variável do tipo char é capaz de armazenar valores de -128 até 127. Se a mesma variável for declarada como sendo do tipo unsigned char, ela será capaz de armazenar valores de 0 até 255.
	
	° O modificador short: esse modificador determina que uma variável do tipo int terá apenas 16 bits (inteiro pequeno), independentemente do processador.
	
	° O modificador long: esse modificador faz o inverso do modificador short. O modificador long determina que uma variável do tipo int terá 32 bits (inteiro grande), independentemente do processador. Também determina que o tipo double possua maior precisão.

	A linguagem C permite que se utilize mais de um modificador de tipo sobre um mesmo tipo. Isso permite, por exemplo, declarar um inteiro grande(ou seja, com 32 bits)usando o modificador (long) e que também seja sem sinal (unsigned). Essa combinação permite aumentar em muito o intervalo de valores possíveis para aquela variável.

12.	A função printf() é uma das funções de saída/escrita de dados da linguagem C. Seu nome vem da expressão em inglês print formatted, ou seja, escrita formatada. Basicamente, a função printf() escreve na saída de vídeo (tela) um conjunto de valores caracteres e/ou sequência de caracteres de acordo com o formato especificado.

13.	A função putchar() (put character) permite escrever um único caractere na tela.

14.	A função scanf() é uma das funções de entrada/leitura de dados da linguagem C. Seu nome vem da expressão em inglês scan formatted, ou seja, leitura formatada. Basicamente, a função scanf() lê do teclado um conjunto de valores, caracteres e/ou sequência de caracteres de acordo com o formato especificado.
	O comando scanf() ignora os espaços em branco entre os tipos de entrada. Qualquer outro caractere inserido entre os tipos de dados deverá ser digitado pelo usuário, mas será descartado pelo programa.

15.	A função getchar() (get character) permite ler um único caractere do teclado.

16.	O escopo de uma variável define onde e quando a variável pode ser usada. Esse escopo está intimamente ligado ao local de declaração dessa variável e, por esse motivo, pode global ou local:
	
	° Uma variável declarada no escopo global, ou simplesmente variável global, é uma variável declarada fora de todas as funções do programa, ou seja, na área de declarações globais do programa. Essas variáveis existem enquanto o programa estiver executando, ou seja, o tempo de vida de vida de uma variável global é o tempo de execução do programa. Além disso essas variáveis poder ser acessadas e alteradas em qualquer parte do programa.
	As variáveis globais devem ser evitadas porque qualquer parte do programa pode alterá-la. Isso prejudica a manutenção do programa, pos torna mais difícil saber onde a variável é inicializada, para que serve etc. Além disso, as variáveis globais ocupam memória durante todo o tempo de execução do programa e não apenas quando são necessárias.

	° Uma variável declarada no escopo local, ou simplesmente variável local, é uma variável declarada dentro de um bloco de comandos delimitado pelo operador de chaves ({}, escopo local). Essas variáveis são visíveis apenas no interior do bloco de comandos onde foram declaradas, ou seja, apenas dentro do seu escopo.
	Quando um bloco possuir uma variável local com o mesmo nome de uma variável global, esse bloco dará preferência à variável local. O mesmo vale para duas variáveis locais em blocos diferentes: a declaração mais próxima sempre tem maior precedência e oculta as demais variáveis com o mesmo nome.

	Como escopo é um assunto delicado e pode gerar muita confusão, evita-se o uso de variáveis com o mesmo nome.

17.	 Uma constante permite guardar determinado dado ou valor na memória do computador, mas com a certeza de que ele não se alterará durante a execução do programa: será sempre o mesmo; portanto, constante. Para constantes, é obrigatória a atribuição do valor no momento da declaração. Na linguagem C existem duas maneiras de criar constantes: usando os comandos #define e const. Além disso a linguagem C possui algumas constantes predefinidas, como as sequências de escape.

	° O comando #define é uma diretiva de compilação que informa ao compilador que ele deve procurar todas as ocorrências da palavra definida e substitui pelo valor da constante quando o programa for compilado.

	° O prefixo const apenas informa ao programa que a variável declarada não poderá ter seu valor alterado. Por ser uma variável, essa constante está sujeita às mesmas regras que regem o uso das variáveis.
	
18.	Um valor literal é a representação de um dado dentro do próprio código-fonte. Trata-se de um valor que é expresso como ele mesmo e não como um valor armazenado em variável ou resultado de uma expressão aritmética. Um valor literal, assim como as variáveis, pertence a determinado tipo de dado. Por exemplo, o valor 10.5 é considerado do tipo double, apesar de a linguagem  possuir três tipos para pontos flutuantes: float, double e long double. A linguagem C permite que indiquemos o tipo de um valor literal pela adição de um sufixo. O sufixo nada mais é do que um caractere de tipo acrescentado ao final do valor literal, sem nenhum espaço entre eles. Eles são úteis para forçar o resultado de uma expressão para um precisão particular.

19.	A linguagem C possui algumas constante predefinidas, como as sequências de escape ou códigos de barra invertida. As sequências de escape permitem o envio de caracteres de controle não gráficos para dispositivos de saída.

-------------------------------
-Capítulo 3 -- As operações que podemos fazer com as variáveis

1.	Uma das operações mais utilizadas em programação é a operação de atribuição "=". Ela é responsável por armazenar determinado valor em uma variável.
	Por expressão entende-se qualquer combinação de valores, variáveis, constantes ou chamadas de funções utilizando os operadores matemáticos +, -, *, / e %, que resulte em uma resposta do mesmo tipo da variável.

2.	A linguagem C também permite a atribuição entre tipos básicos diferentes. O compilador converte automaticamente o valor do lado direito para o tipo do lado esquerdo do comando de atribuição "=". Durante a etapa de conversão de tipos, pode haver perda de informação.

3.	Os operadores aritméticos são aqueles que operam sobre números ( valores, variáveis, constantes ou chamadas de funções ) e/ou expressões e têm como resultados valores númericos. A linguagem C possui um total de cinco operadores aritméticos.
	Os operadores aritméticos são sempre usados em conjunto com o operador de atribuição. Afinal de contas, alguém precisa receber o resultado da expressão aritmética.

4.	Em uma expressão, as operações de multiplicação, divisão e resto são executadas antes das operações de adição e subtração. Para forçar um operação a ser executada antes das demais, ela é colocada entre parênteses.

5.	O operador de subtração também pode ser utilizado para inverter o sinal de um número.
	De modo geral, os operadores aritméticos são operadores binários, ou seja, atuam sobre dois valores. Mas os operadore de adição e subtração também podem ser aplicados sobre um único valor. Nesse caso, eles são chamados de operadores unários.

6.	Em uma operação utilizando o operador de quociente /, se o numerador e o denominador forem números inteiros, por padrão o compilador retornará apenas a parte inteira da divisão.
	O operador de resto da divisão (%) só é válido para valores inteiros (tipo int e char).

7.	Os operadores relacionais são aqueles que operam sobre dois valores(valores, variáveis, constantes ou chamadas de funçoes) e/ou expressões e verificam a magnitude(qual e o maior ou menor) e/ou igualdade entre eles. Os operadores relacionais são operadores de comparação de valores. A linguagem C possui um total de seis operadores relacionais.

8.	Os operadores lógicos permitem representar situações lógicas unindo duas ou mais expressões relacionais simples em uma composta:
	° Operador E (&&): a expressão resultante só é verdadeira se ambas as expressões unidas por esse operador também forem.
	
	° Operador OU (||): a expressão resultante é verdadeira se alguma das expressões unidas por esse operador também for.
	
	° O operador NEGAÇÂO (!): inverte o valor lógico da expressão à qual se aplica.

9.	A linguagem C permite que se façam operações "bit a bit" em valores númericos. Os operadores bit a bit permitem que o programador faça operações em cada bit do número de maneira direta. Os operadores bit a bit ajudam os programadors que queiram trabalhar com o computador em "baixo nível". A linguagem C possui um total de seis operadores bit a bit.
	Os operadores só podem ser usados nos tipos char, int e long, não podem ser aplicados sobre os valores dos tipos float e double. Em parte, isso se deve à maneira como um valor real, também conhecido como ponto flutuante, é representado nos computadores, que é bem mais complexa: não se trata de apenas um conjunto de 0s e 1s na memória.

10.	Basicamente, os operadores &, | e ^ fazem um comparação lógica para cada um dos bits dos valores avaliados, como explicado a seguir:
	° O operador E bit a bit (&): um bit terá valor 1 na expressão resultante some se ambas as expressões unidas por esse operador também tiverem o valor 1 nos bits daquela posição.	

	° O operador OU bit a bit (|): um bit terá valor 1 na expressão resultante se alguma das expressões unidas por esse operador também tiver o valor 1 no bit daquela posição.
	
	° O operador OU EXCLUSIVO bit a bit (^): um bit terá um valor 1 na expressão resultante somente se ambas as expressões unidas por esse operador tiverem valores de bits diferentes naquela posição.

11. Os operadores "<<" e ">>", servem simplesmente para mover N bits para a esquerda ou para a direita.
	Basicamente, os operadores de deslocamento << e >> movimentam todos os bits de um valor para a esquerda ou para a direita, colocando novos valores de bits(que podem ser 0s ou 1s) nos lugares vagos. Cada movimentaçao de bits equivale a multiplicar ou dividir(divisão inteira) por 2.

12.	Além dos operadores simplificados, a linguagem C também possui operadores de incremento(++) e decremento(--). Esses operadores podem ser utilizados sempre que for necessário somar uma unidade (incremento) ou subtrair uma unidade (decremento) a determinado valor:
	
	° ++x(pré-incremento): soma +1 à variável x antes de utilizar seu valor.

	° x++(pós incremento): soma +1 à variável x depois de utilizar seu valor.

	° --x(pré-decremento): subtrai -1 da variável x antes de utilizar seu valor.
	
	° x--(pós-decremento): subtrai -1 da variável x depois de utilizar seu valor.

13.	Modeladores de tipos (também chamados de type cast) são uma forma explícita de conversão de tipo, na qual o tipo a ser convertido é explicitamente definido dentro de um programa. Isso é diferente da conversão implícita, que ocorre naturalmente quanto tentamos atribuir um número real a uma variável inteira.
	Um modelador de tipo é colocado em frente de uma expressão e tem como objetivo forçar o resultado da expressão a ser de um tipo especificado.

14. Na linguagem C, o operador vírgula (,), pode ser utilizado de duas maneiras:
	° Como pontuação, para separar argumentos de uma função;
	° Para determinar uma lista de expressões que devem ser executadas sequencialmente. Pode-se encadear quantos operadores "," forem necessários.
	
	Na linguagem C, o operador "," é um separador de comandos, enquanto o operador ";" é um terminador de comandos.

15.	A linguagem C contém muitos operadores. Consequentemente, o uso de múltiplos operadores em uma única expressão pode tornar confusa a sua interpretação. Por esse motivo, a linguagem C possui uma série de regras de precedência de operadores. Isso permite que o compilador possa decidir corretamente qual a ordem em que os operadores deverão ser executados em um expressão contendo vários. Para forçar o compilador a executar uma parte da expressão antes das demais pode-se utilizar os parênteses.

16.	Link with the math library: gcc <nameOfFile> <nameOfFile.c> -lm

-------------------------------
-Capítulo 4 -- Comandos de controle condicional

1.	Por condição entende-se qualquer expressão relacional que resulte em uma reposta do tipo verdadeiro ou falso. Ela pode ser contruída utilizando operadores matemáticos, relacionais ou lógicos.

2.	Quando o compilador avalia uma condição, ele quer um valor de retorno (verdadeiro ou falso) para poder tomar a decisão. No entanto, essa expressão condicional não necessita ser uma expressão no sentido convencional. Uma variável sozinha pode ser uma "expressão condicional" e retornar o seu próprio valor.

3.	Na linguagem C, o comando if é utilizado sempre que é necessário escolher entre dois caminhos dentro do programa ou quando se deseja executar um ou mais comando que estejam sujeitos ao resultado de um teste.
	Na execução do comando if a condição será avaliada e se a condição for verdadeira, a sequência de comandos será executada, se a condição for falsa, a sequência de comandos não será executada, e o programa continuará a partir do primeiro comando seguinte ao final do comando if.

4.	Diferentemente da maioria dos comandos, não se usa o ponto e vírgula (;) depois da condição do comando if. Na linguagem C, o operador ponto e vírgula (;) é utilizado para separar as instruções do programa. Colocá-lo logo após o comando if, faz com que o compilador entenda que o comando if já terminou e trate o comando seguinte como se ele estivesse fora do if. O compilador não acusará um erro se colocarmos o operador ponto e vírgula (;) após o comando if, mas a lógica do programa poderá estar errada.

5.	No comando if, e em diversos outros comandos da linguagem C, usam-se os operadores de chaves ({}) para delimitar um bloco de instruções. Por definição, comandos de condição (if e else) ou repetição (while, for, do while) atuam apenas sobre o comando seguinte a eles. Desse modo, se o programador desejar que mais de uma instrução seja executada por aquele comando if, esse conjunto de instruções deve estar contido dentro de um bloco delimitado por chaves ({}). As chaves podem ser ignoradas se o comando contido dentro do if for único.

6.	O comando else pode ser entendido como um complemento do comando if. Ele auxilia o comando if na tarefa de escolher entre os vários caminhos a serem seguidos dentro do programa.
	O comando else é opcional, e sua sequência de comandos somente será executada se o valor da condição que está sendo testada pelo comando if for FALSA. Se o comando if diz o que fazer quando a condição é verdadeira, o comando else trata da condição quando ela é feita.
	O comando else deve ser entendido como um complemento do comando if. Ele diz quais comandos se deve executar se a condição do comando if for falsa. Portanto, não é necessário estabelecer uma condição para o comando else: ele é o oposto do if.
	Como no caso de if, não se usa o ponto e vírgula (;) depos do comando else.

7.	Um if aninhado é simplesmente um comando if utilizado dentro do bloco de comandos de um outro if (ou else) mais externo. Basicamente, é um comando if dentro de outro.

8.	O operador ? é também conhecido como operador ternário. Trata-se de uma simplificação do comando if-else, ou seja, com apenas um comando e não blocos de comandos. O operador de ? é tipicamente utilizado para atribuições condicionais.

9.	Além dos comandos if e else, a linguagem C possui um comando de seleção múltipla chamado switch. Esse comando é muito parecido com o aninhamento de comando if-else-if.
	O comando switch é muito mais limitado que o comando if-else: quando o comando if pode testar expressões lógicas ou relacionais, o comando switch somente verifica se uma váriavel ( do tipo int ou char ) é ou não igual a certo valor constante.
	O comando switch é indicado quando se deseja testar uma variável em relação a diversos valroes preestabelecidos.
	O comando default é opcional, e sua sequência de comandos somente será executada se o valor da variável que está sendo testada pelo  comando switch não for igual a nenhum dos valores dos comandos case.
	O comando break é opcional e faz com que o comando switch seja interrompido assim que uma das sequências de comandos é executada.
	Quando o valor associado a um comando case é igual ao valor da variável do switch, a respectiva sequência de comandos é executada até encontrar um comando break. Caso o comando break não exista, a sequência de comandos do case seguinte também será executada, e assim por diante.
	De modo geral, a sequência de comandos case não precisa estar entre chaves ({}). Mas se o primeiro comando dentro de um case for a declaração de uma variável, será necessário colocar todos os comandos desse case dentro de um par de chaves ({}). A explicação para esse comportamento do switch se deve a uma regra da linguagem que especifica que um salto condicional não pode pular uma declaração de variável no mesmo escopo. Quando colocamos as ({}) depois do comando case e antes do comando break, estamos criando um novo escopo, ou seja, a variável declarada existe apenas dentro desse par de chaves. Portanto, ela pode ser pulada por um salto condicional.

-------------------------------
-Capítulo 5 -- Comandos de repetição

1.	Há casos em que é preciso que um bloco de comandos seja executado mais de uma vez se determinada condição for verdadeira. Para isso, precisamos de uma estrutura de repetição que permita executar um conjunto de comandos quantas vezes forem necessárias. Isso é muito similar ao que ocorre em um fluxograma, em que o símbolo de losango permitia escolher entre diferentes caminhos com base em uma condição do tipo verdadeiro/falso, com a diferença de que agora o fluxo do programa é desviado novamente para a condição ao final da sequência de comandos.
	De acordo com a condição, os comandos serão repetidos zero (se falsa) ou mais vezes (enquanto a condição for verdadeira). Essa estrutura normalmente é denominada laço ou loop. A sequência de comandos a ser repetida está subordinada a uma condição. Por condição entende-se qualquer expressão relacional que resulte em uma resposta do tipo verdadeiro ou falso. A condição pode ainda ser uma expressão que utiliza os operadores matemáticos, relacionais ou lógicos.

2.	Laço infinito (ou loop infinito) é um sequência de comandos em um programa de computador que sempre se repete, ou seja, infinitamente. Isso geralmente ocorre por algum erro de programaçãom, quando não definimos uma condição de parada ou a condição de parada existe, mas nunca é atingida.

3.	Na execução do comando while, a condição será avaliada e se a condição for considerada verdadeira a sequência de comandos será executada. Ao final da sequência de comandos, o fluxo do programa é desviado novamente para o teste da condição.

4.	Como nos comandos condicionais, o comando while atua apenas sobre o comando seguinte a ele. Se quisermos que ele execute uma sequência de comandos, é preciso definir essa sequência de comandos dentro de chaves ({}).

5.	O comando for basicamente, é usado para repetir um comando ou uma sequência de comandos diversas vezes. Na execução do comando for, é realizada esta sequência de passos:
	° A cláusula inicialização é executada: nela as variáveis recebem um valor inicial para usar dentro do for.
	
 	° Se a condição for considerada verdadeira, a sequência de comandos será executada. Ao final da sequência de comandos, o fluxo do programa é desviado para o incremento.
	
	° Terminada a execução da sequência de comandos, ocorre a etapa de incremento das variáveis usadas no for. Ao final dessa etapa, o fluxo do programa é novamente desviado para a condição.

	Dependendo da situação em que o comando for é utilizado, podemos omitir qualquer uma de suas cláusulas: inicialização, condição ou incremento. Independetemente de qual cláusula é omitida, o comando for exige que se coloquem os dois operadores de ponto e virgula (;), pois esse operador que indica a separação entre as cláusulas de inicialização, condição e incremento. Sem elas, o compilador não tem certeza de qual cláusula foi omitida.
	A cláusula de incremento é utilizada para atribuir um novo valor a uma ou mais variáveis durante o comando for. Essa atribuição não está restrita apenas ao operador de incremento (++). A cláusula de incremento pode conter qualquer comando que altere o valor de uma das variáveis utilizadas pelo comando for.

6.	Na linguagem C, o operador ",", é um separador de comandos. Ele permite determinar uma lista de expressões que devem ser executadas sequencialmente, inclusive dentro do for.

7.	O comando do-while é bastante semelhante ao comando while visto anteriormente. Sua principal diferença é com relação à avaliação: enquanto o comando while avalia a condição para depois executar uma sequência de comandos, o comando do-while executa uma sequência de comandos para depois testar a condição. O comando do-while é utilizado sempre que se desejar que a sequência de comandos seja executar pelo menos uma vez.
	No comando do while, a sequência de comandos é definida antes do teste da condição, diferentemente dos outros comandos condicionais e de repetição. Isso significa que o teste da condição é o último comando da repetição do-while. Sendo assim, o compilador entende que a definição do comando do-while já terminou e exige que se coloque o operador de ponto e vírgula (;) após a condição.

8.	Uma repetição aninhada é simplesmente um comando de repetição utilizado dentro do bloco de comandos de um outro comando de repetição. Basicamente, é um comando de repetição dentro de outro, semelhante ao que é feito com o comando if.
	O aninhamento de comandos de repetição é muito útil quando se tem de percorrer dois conjuntos de valores que estão relacionados dentro de um programa.

9.	O comando break serve para quebrar a execução de um conjunto de comandos ou interromper a execução de qualquer comando de repetição. O comando break faz com que a execução do programa continue na primeira linha seguinte ao laço que está sendo interrompido, terminando de forma abrupta uma repetição.
	O comando break deverá sempre ser colocado dentro de um comando if ou else que está dentro da repetição. Isso ocorre porque o comando break serve para interromper a execução de qualquer comando de repetição. Porém, esse comando de repetição só deve ser interrompido se ocorrer determinado resultado.

10.	O comando continue é muito parecido com o comando break. Tanto o break quanto o continue ignoram da sequência de comandos da repetição que os sucedem. A diferença é que, enquanto o comando break termina o comando de repetição que está sendo executado, o comando continue interrrompe apenas aquela repetição e passa para a próxima repetição do laço, se ela existir. Por esse mesmo motivo, o comando continue só pode ser utilizado dentro de um laço.
	Quando o comando continue é executado, os comandos restates da repetição são ignorados. O programa volta a testar a condição do laço para saber se ele deve ser executado novamente ou não.
	O comando assim como o comando break deverá sempre ser colocado dentro de um if ou else que está dentro da repetição.

11.	O comano goto é um salto condicional para um local especificado por uma palavra-chave no código. O comando goto muda o fluxo do programa para um local previamente especificado. Esse local pode ser à frente ou atrás no programa, mas deve ser dentro da mesma função.

-------------------------------
-Capítulo 6 -- Vetores e matrizes - arrays

1.	Cada variável está associada a uma úncia posição de memória, e dentro dela é possível armazenar apenas um valor do tipo especificado. Assim, para armazenar mais de um valor, é preciso usar mais de uma variável.

2.	Um array ou "vetor" é a forma mais simples e comum de dados estruturados da linguagem C. Trata-se simplesmente de um conjunto de variáveis de um mesmo tipo, com a vantagem de estarem todas associadas ao mesmo nome e igualmente acessíveis por um índice.

3.	O tamanho de um array deve ser sempre um valor ou expressão inteira e constante.

4.	O acesso ao valor de cada nota é feito utilizando um índice. Para indicar qual índice do array queremos acessar, utiliza-se o operador de colchetes ([]).

5.	Como o array possui um índice, podemos usar comandos de repetição para executar repetidamente um mesmo comando para cada posição do array. Desse modo, não é mais necessário reescrever um mesmo comando para a posição do array. Isso torna o código mais enxuto, facilitando a sua manutenção e minimizando a ocorrência de erros. 
	O uso de arrays permite usar comandos de repetição sobre tarefas que devem ser realizadas, de forma idêntica, para cada posição do array, apenas modificando o índice do array. Além disso, cada posição do array possui todas as características de uma variável. Isso significa que ela pode aparecer em comandos de entrada e saída de dados, expressões e atribuições.

5.	Na linguagem C, a numeração do índice do array começa sempre do ZERO e termina sempre em N-1, em que N é o número de elementos definido na declaração do array. Isso acontece pelo seguinte motivo: um array é um agrupamento de dados do mesmo tipo, adjacentes na memória. O nome do array indica onde esses dados começam na memória. O índice do array indica quantas posições se deve pular para acessar determinada posição.

6.	Em um array de 100 elementos, índices menores do que 0 e maiores do que 99 também podem ser acessados. Porém, isso pode resultar nos mais variados erros durante a execução do programa. Isso significa que, se tentarmos acessar o índice 100, o programa tentará acessar a centésima posição a partir da posiçao inicial ( que é o nome do array ). O mesmo vale para a posição de índice -1. Nesse caso, o programa tentará acessar uma posição anterior ao local onde oa rray começa na memória. O problema é que, apesar de essas posições existirem na memória e serem acessíveis, elas não pertencem ao array. Pior ainda, elas podem pertencer a outras variáveis do programa, e alteração de seus valores pode resultar nos mais variados erros durante a execução do programa.

7.	Não se pode fazer atribuição de arrays inteiros, apenas de suas posições individualmente. Isso ocorre porque a linguagem C não suporta a atribuição de um array para outro. Para atribuir o conteúdo de um array a outro array, o correto é copiar seus valores elemento por elemento para o outro array.

8.	Há casos em que uma estrutura com mais de uma dimensão é mais útil. Por exemplo quando os dados são organizados em uma estrutura de linas e colunas, como uma tabela, Para isso, usamos um array com duas dimensões, ou seja, uma "matriz".

9.	Para acessar determinada posição da matriz, precisamos usar dois índices: o primeiro índice especifica a linha, e o segundo, a coluna da nossa matriz. Note que cada índice possui o seu próprio par de colchetes ([]). Como no caso do vetor, cada dimensão começa no índice ZERO e termina sempre em N-1, em que N é o número de elementos definido par aquela dimensão da matriz. Assim, em uma matriz declarada com 100 linhas e 50 colunas, a numeração das linhas vai de 0 até 99, enquanto a numeração das colunas vai de 0 até 49.

10.	Como no caso dos vetores, podemos aqui também usar comandos de repetição sobre tarefas que devem ser realizadas, de forma idêntica, para cada posição da matriz, apenas modificando os seus índices. Como uma matriz possui dois índices, precisamos de dois comandos de repetição para percorrer todos os seus elementos. 

11.	Cada posição do array é uma variável. Portanto, todas as posições do array são igualmente acessíveis, isto é, o tempo e o tipo de procedimento para acessar qualquer uma das posções do array são iguais aos de qualquer outra variável.

12. A linguagem C permite que se crie um array com mais de duas dimensões de maneira fácil. Para criar um vetor, utilizamos um par de colchetes. Ou seja, cada dimensão do array é definida por um par de colchetes na sua declaração.

13.	Apesar de terem o comportamento de estruturas com mais de uma dimensão, os dados dos arrays, independetemente do número de dimensões que possuam, são sempre armazenados linearmente na memória. É o uso dos colchetes que cria a impressão de estarmos trabalhando com mais de um dimensão. 
	Por esse motivo, é importante ter em mente qual dimensão se move mais rapidamente na memória: sempre a mais à direita, independentemente do tipo ou do número de dimensões do array.

14.	Arrays são variáveis. Assim, a declaração de um arary apenas reserva espaço na memória e não associa a eles nenhum valor. Seu valor inicial é o lixo de memória contido no espaço reservado para ele. A depender do programa que estamos construindo, é preciso iniciar todas as posições do array com algum valor predefinido.

15.	O operador de chaves permite definir uma lista de valores a serem atribuídos ao array durante a sua declaração: {dados}. Nessa declaração, dados são uma lista de valores (do mesmo tipo do array) separados por vírgula e delimitados pelo operador de chaves ({}). Esses valores devem ser colocados na mesma ordem em que serão colocados dentro do array, começando da sua primeira posição, a posição zero. A inicialização de um array utilizando o operador de chaves ({}) só pode ser feita durante sua declaração.

16.	Na inicialização de um array, não é necessário definir o valor de todas as suas posições. As posições não definidas serão inicializadas com o valor ZERO ou o caractere correspondente ao valor ZERO.

17.	A linguagem C também permite inicializar um array sem que tenhamos definido o seu tamanho. Nesse caso, simplesmente não colocamos o valor do tamanho do array entre os colchetes durante a sua declaração.
	Nesse tipo de inicialização, o compilador da linguagem C vai contar quantos valores existem na lista de dados definida para a inicialização do array. Em seguida, ele vai considerar essa quantidade de valores como o tamanho do array. Isso ocorre na etapa de compilação do programa. Depois disso, o tamanho do array não poderá mais ser modificado.

18.	Array de caracteres sempre possuem o elemento seguinte ao último caractere como sendo o caractere "\0".

19.	No caso da inicialização de arrays com mais de uma dimensão, é necessário sempre definir as dimensões que existem além da primeira. Apenas a primeira dimensão pode ficar sem tamanho definido.

-------------------------------
-Capítulo 7 -- Arrays de caracteres - strings

1.	String é o nome que usamos para definir uma sequência de caracteres adjacentes na memória do computador. Essa sequência de caracteres, que pode ser uma palavra ou frase, é armazenada na memória do computador na forma de um array do tipo char.
	Por ser a string um array de caracteres, sua declaração segue as mesmas regras da declaração de um array convencional. No entanto, apesar de ser um array, devemos ficar atentos para o fato de que as strings têm no elemento seguinte a última letra da palavra/frase armazenada, um caractere "\0". O caractere "\0" indica o fim da sequência de caracteres.
	Isso ocorre porque podemos definir uma string com tamanho maior do que a palavra armazenada. Imagine uma string definida com tamanho de 50 caracteres, mas utilizada apenas para armazenar a palavra "oi". Nesse caso, temos 48 posições não utilizadas e que estão preenchidas com lixo de memória ( um valor qualquer ). Obviamente, não queremos que todo esse lixo seja impresso quando essa string for exibida na tela. Assim, o caractere "\0" indica o fim da sequência de caracteres e o início das posições restantes da nossa string que não estão sendo utilizadas nesse momento.
	Ao definir o tamanho de uma string, devemos considerar o caractere "\0". Como o caractere "\0" indica o final de nossa string, isso significa que, em uma string definida com tamanho de 50 caracteres, apenas 49 estarão disponíveis para armazenar o texto digitado pelo usuário.

2.	Uma string pode ser lida do teclado ou já ser definida com um valor inicial. Para sua inicialização, pode-se usar o mesmo princípio definido na inicialização de vetores e matrizes.

3.	Outro ponto importante na manipulação de strings é que, por se tratar de um array, cada caractere pode ser acessado individualmente por indexação como em qualquer outro vetor ou matriz.
	Na atribuição de strings usam-se aspas duplas, enquanto na de caracteres usam-se aspas simples.

4.	A linguagem C possui funções especialmente desenvolvidas para a manipulação de strings na biblioteca <string.h>.

5.	Quando usamos a função scanf() para ler uma string, o símbolo de & antes do nome da variável não é utilizado. Os colchetes também não são utilizados, pois queremos ler a string toda e não apenas uma letra. A função scanf() lê apenas strings digitadas sem espaços, ou seja, palavras.

6.	Uma alternativa mais eficiente para a leitura de uma string é a função gets(), a qual faz a leitura do teclado considerando todos os caracteres digitados ( incluindo os espaços ) até encontrar uma tecla enter.

7.	Outra função que, utilizada de forma adequada, também permite a leitura de strings do teclado. Essa função é a fgets(). Para ler do teclado, basta substituir FILE *fp por stdin, o qual o dispositivo de entrada-padrão ( geralmente o teclado ).
	Como a função gets(), a função fgets() lê a string do teclado até que um caractere de nova linha (enter) seja lido. Apesar de parecerem iguais, a função fgets possui algumas diferenças e vantagens sobre a gets(). Na função fgets(), o caractere de nova linha ("\n") fará parte da string, o que não acontecia com a gets().

8.	Para resolver o erro de sujeira no buffer, podemos limpar o buffer do teclado (entrada-padrão) usando a função setbuf(stdin, NULL) antes de realizar a leitura de caracteres ou strings.
	Basicamente, a função setbuf() preenche um buffer (primeiro parâmetro) com determinado valor ( segundo parâmetro). Na linguagem C, a palavra NULL é uma constante-padrão que significa um valor nulo. Um buffer preenchido com NULL é considerado limpo/vazio.

9.	Basicamente, para escrever uma string na tela utilizamos a função printf() com o formato de dado "%s". Os colchetes não são utilizados, pois queremos escrever a string toda e não apenas uma letra.

10.	Existe uma outra função que, se utilizada de forma adequada, também permite a escrita de strings na tela. Essa função é a fputs().

11.	Para obter o tamanho de uma string, usa-se a função strlen().

12.	Para realizar a cópia de uma string, usa-se a função strcpy(). Para evitar o estouro de buffer, o tamanho do array destino deve ser longo o suficiente para conter a sequência de caracteres contida em origem.

13.	A operação de concatenação é outra tarefa bastante comum ao se trabalhar com strings. Basicamente, essa operação consiste em copiar uma string para o final de outra string. Na linguagem C, para fazer a concatenação de duas strings, usa-se a função strcat().

14.	Da mesma maneira como o operador de atribuição não funciona para strings, o mesmo ocorre com operadores relacionais usados para comparar duas strings. Desse modo, para saber se duas strings são iguais usa-se a função strcmp().